/* Copyright (c) 2013-2014, Cornell University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of HyperDex nor the names of its contributors may be
 *       used to endorse or promote products derived from this software without
 *       specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* This file is generated by bindings/ruby.py */

static VALUE
hyperdex_ruby_client_asynccall__spacename_key__status_attributes(int64_t (*f)(struct hyperdex_client* client, const char* space, const char* key, size_t key_sz, enum hyperdex_client_returncode* status, const struct hyperdex_client_attribute** attrs, size_t* attrs_sz), VALUE self, VALUE spacename, VALUE key)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const char* in_key;
    size_t in_key_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    const struct hyperdex_client_attribute** attrs = IV2PTR(deferred, "@attrs_ptr");
    size_t* attrs_sz = IV2PTR(deferred, "@attrs_sz_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_key(arena, key, &in_key, &in_key_sz);

    reqid = f(client, in_space, in_key, in_key_sz, status, attrs, attrs_sz);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);
    rb_iv_set(deferred, "@attrs", Qtrue);
    rb_iv_set(deferred, "@attrs_sz", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_attributenames__status_attributes(int64_t (*f)(struct hyperdex_client* client, const char* space, const char* key, size_t key_sz, const char** attrnames, size_t attrnames_sz, enum hyperdex_client_returncode* status, const struct hyperdex_client_attribute** attrs, size_t* attrs_sz), VALUE self, VALUE spacename, VALUE key, VALUE attributenames)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const char* in_key;
    size_t in_key_sz;
    const char** in_attrnames;
    size_t in_attrnames_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    const struct hyperdex_client_attribute** attrs = IV2PTR(deferred, "@attrs_ptr");
    size_t* attrs_sz = IV2PTR(deferred, "@attrs_sz_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_key(arena, key, &in_key, &in_key_sz);
    hyperdex_ruby_client_convert_attributenames(arena, attributenames, &in_attrnames, &in_attrnames_sz);

    reqid = f(client, in_space, in_key, in_key_sz, in_attrnames, in_attrnames_sz, status, attrs, attrs_sz);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);
    rb_iv_set(deferred, "@attrs", Qtrue);
    rb_iv_set(deferred, "@attrs_sz", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_attributes__status(int64_t (*f)(struct hyperdex_client* client, const char* space, const char* key, size_t key_sz, const struct hyperdex_client_attribute* attrs, size_t attrs_sz, enum hyperdex_client_returncode* status), VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const char* in_key;
    size_t in_key_sz;
    const struct hyperdex_client_attribute* in_attrs;
    size_t in_attrs_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_key(arena, key, &in_key, &in_key_sz);
    hyperdex_ruby_client_convert_attributes(arena, attributes, &in_attrs, &in_attrs_sz);

    reqid = f(client, in_space, in_key, in_key_sz, in_attrs, in_attrs_sz, status);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(int64_t (*f)(struct hyperdex_client* client, const char* space, const char* key, size_t key_sz, const struct hyperdex_client_attribute_check* checks, size_t checks_sz, const struct hyperdex_client_attribute* attrs, size_t attrs_sz, enum hyperdex_client_returncode* status), VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const char* in_key;
    size_t in_key_sz;
    const struct hyperdex_client_attribute_check* in_checks;
    size_t in_checks_sz;
    const struct hyperdex_client_attribute* in_attrs;
    size_t in_attrs_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_key(arena, key, &in_key, &in_key_sz);
    hyperdex_ruby_client_convert_predicates(arena, predicates, &in_checks, &in_checks_sz);
    hyperdex_ruby_client_convert_attributes(arena, attributes, &in_attrs, &in_attrs_sz);

    reqid = f(client, in_space, in_key, in_key_sz, in_checks, in_checks_sz, in_attrs, in_attrs_sz, status);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key__status(int64_t (*f)(struct hyperdex_client* client, const char* space, const char* key, size_t key_sz, enum hyperdex_client_returncode* status), VALUE self, VALUE spacename, VALUE key)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const char* in_key;
    size_t in_key_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_key(arena, key, &in_key, &in_key_sz);

    reqid = f(client, in_space, in_key, in_key_sz, status);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_predicates__status(int64_t (*f)(struct hyperdex_client* client, const char* space, const char* key, size_t key_sz, const struct hyperdex_client_attribute_check* checks, size_t checks_sz, enum hyperdex_client_returncode* status), VALUE self, VALUE spacename, VALUE key, VALUE predicates)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const char* in_key;
    size_t in_key_sz;
    const struct hyperdex_client_attribute_check* in_checks;
    size_t in_checks_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_key(arena, key, &in_key, &in_key_sz);
    hyperdex_ruby_client_convert_predicates(arena, predicates, &in_checks, &in_checks_sz);

    reqid = f(client, in_space, in_key, in_key_sz, in_checks, in_checks_sz, status);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(int64_t (*f)(struct hyperdex_client* client, const char* space, const char* key, size_t key_sz, const struct hyperdex_client_map_attribute* mapattrs, size_t mapattrs_sz, enum hyperdex_client_returncode* status), VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const char* in_key;
    size_t in_key_sz;
    const struct hyperdex_client_map_attribute* in_mapattrs;
    size_t in_mapattrs_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_key(arena, key, &in_key, &in_key_sz);
    hyperdex_ruby_client_convert_mapattributes(arena, mapattributes, &in_mapattrs, &in_mapattrs_sz);

    reqid = f(client, in_space, in_key, in_key_sz, in_mapattrs, in_mapattrs_sz, status);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(int64_t (*f)(struct hyperdex_client* client, const char* space, const char* key, size_t key_sz, const struct hyperdex_client_attribute_check* checks, size_t checks_sz, const struct hyperdex_client_map_attribute* mapattrs, size_t mapattrs_sz, enum hyperdex_client_returncode* status), VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const char* in_key;
    size_t in_key_sz;
    const struct hyperdex_client_attribute_check* in_checks;
    size_t in_checks_sz;
    const struct hyperdex_client_map_attribute* in_mapattrs;
    size_t in_mapattrs_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_key(arena, key, &in_key, &in_key_sz);
    hyperdex_ruby_client_convert_predicates(arena, predicates, &in_checks, &in_checks_sz);
    hyperdex_ruby_client_convert_mapattributes(arena, mapattributes, &in_mapattrs, &in_mapattrs_sz);

    reqid = f(client, in_space, in_key, in_key_sz, in_checks, in_checks_sz, in_mapattrs, in_mapattrs_sz, status);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}

static VALUE
hyperdex_ruby_client_iterator__spacename_predicates__status_attributes(int64_t (*f)(struct hyperdex_client* client, const char* space, const struct hyperdex_client_attribute_check* checks, size_t checks_sz, enum hyperdex_client_returncode* status, const struct hyperdex_client_attribute** attrs, size_t* attrs_sz), VALUE self, VALUE spacename, VALUE predicates)
{
    VALUE iterator;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const struct hyperdex_client_attribute_check* in_checks;
    size_t in_checks_sz;
    int64_t reqid;
    iterator = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Iterator"));
    struct hyperdex_ds_arena* arena = IV2PTR(iterator, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(iterator, "@status_ptr");
    const struct hyperdex_client_attribute** attrs = IV2PTR(iterator, "@attrs_ptr");
    size_t* attrs_sz = IV2PTR(iterator, "@attrs_sz_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_predicates(arena, predicates, &in_checks, &in_checks_sz);

    reqid = f(client, in_space, in_checks, in_checks_sz, status, attrs, attrs_sz);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(iterator, "@status", Qtrue);
    rb_iv_set(iterator, "@attrs", Qtrue);
    rb_iv_set(iterator, "@attrs_sz", Qtrue);

    rb_iv_set(iterator, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), iterator);
    return iterator;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_predicates__status_description(int64_t (*f)(struct hyperdex_client* client, const char* space, const struct hyperdex_client_attribute_check* checks, size_t checks_sz, enum hyperdex_client_returncode* status, const char** description), VALUE self, VALUE spacename, VALUE predicates)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const struct hyperdex_client_attribute_check* in_checks;
    size_t in_checks_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    const char** description = IV2PTR(deferred, "@description_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_predicates(arena, predicates, &in_checks, &in_checks_sz);

    reqid = f(client, in_space, in_checks, in_checks_sz, status, description);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);
    rb_iv_set(deferred, "@description", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}

static VALUE
hyperdex_ruby_client_iterator__spacename_predicates_sortby_limit_maxmin__status_attributes(int64_t (*f)(struct hyperdex_client* client, const char* space, const struct hyperdex_client_attribute_check* checks, size_t checks_sz, const char* sort_by, uint64_t limit, int maxmin, enum hyperdex_client_returncode* status, const struct hyperdex_client_attribute** attrs, size_t* attrs_sz), VALUE self, VALUE spacename, VALUE predicates, VALUE sortby, VALUE limit, VALUE maxmin)
{
    VALUE iterator;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const struct hyperdex_client_attribute_check* in_checks;
    size_t in_checks_sz;
    const char* in_sort_by;
    uint64_t in_limit;
    int in_maxmin;
    int64_t reqid;
    iterator = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Iterator"));
    struct hyperdex_ds_arena* arena = IV2PTR(iterator, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(iterator, "@status_ptr");
    const struct hyperdex_client_attribute** attrs = IV2PTR(iterator, "@attrs_ptr");
    size_t* attrs_sz = IV2PTR(iterator, "@attrs_sz_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_predicates(arena, predicates, &in_checks, &in_checks_sz);
    hyperdex_ruby_client_convert_sortby(arena, sortby, &in_sort_by);
    hyperdex_ruby_client_convert_limit(arena, limit, &in_limit);
    hyperdex_ruby_client_convert_maxmin(arena, maxmin, &in_maxmin);

    reqid = f(client, in_space, in_checks, in_checks_sz, in_sort_by, in_limit, in_maxmin, status, attrs, attrs_sz);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(iterator, "@status", Qtrue);
    rb_iv_set(iterator, "@attrs", Qtrue);
    rb_iv_set(iterator, "@attrs_sz", Qtrue);

    rb_iv_set(iterator, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), iterator);
    return iterator;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_predicates__status(int64_t (*f)(struct hyperdex_client* client, const char* space, const struct hyperdex_client_attribute_check* checks, size_t checks_sz, enum hyperdex_client_returncode* status), VALUE self, VALUE spacename, VALUE predicates)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const struct hyperdex_client_attribute_check* in_checks;
    size_t in_checks_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_predicates(arena, predicates, &in_checks, &in_checks_sz);

    reqid = f(client, in_space, in_checks, in_checks_sz, status);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}

static VALUE
hyperdex_ruby_client_asynccall__spacename_predicates__status_count(int64_t (*f)(struct hyperdex_client* client, const char* space, const struct hyperdex_client_attribute_check* checks, size_t checks_sz, enum hyperdex_client_returncode* status, uint64_t* count), VALUE self, VALUE spacename, VALUE predicates)
{
    VALUE deferred;
    struct hyperdex_client* client = IV2PTR(self, "@client");
    const char* in_space;
    const struct hyperdex_client_attribute_check* in_checks;
    size_t in_checks_sz;
    int64_t reqid;
    deferred = rb_class_new_instance(1, &self, rb_path2class("HyperDex::Client::Deferred"));
    struct hyperdex_ds_arena* arena = IV2PTR(deferred, "@arena_ptr");
    enum hyperdex_client_returncode* status = IV2PTR(deferred, "@status_ptr");
    uint64_t* count = IV2PTR(deferred, "@count_ptr");
    hyperdex_ruby_client_convert_spacename(arena, spacename, &in_space);
    hyperdex_ruby_client_convert_predicates(arena, predicates, &in_checks, &in_checks_sz);

    reqid = f(client, in_space, in_checks, in_checks_sz, status, count);

    if (reqid < 0)
    {
        hyperdex_ruby_client_throw_exception(*status, hyperdex_client_error_message(client));
    }

    rb_iv_set(deferred, "@status", Qtrue);
    rb_iv_set(deferred, "@count", Qtrue);

    rb_iv_set(deferred, "@reqid", LONG2NUM(reqid));
    rb_hash_aset(rb_iv_get(self, "@ops"), LONG2NUM(reqid), deferred);
    return deferred;
}
static VALUE
hyperdex_ruby_client_get(VALUE self, VALUE spacename, VALUE key)
{
    return hyperdex_ruby_client_asynccall__spacename_key__status_attributes(hyperdex_client_get, self, spacename, key);
}
VALUE
hyperdex_ruby_client_wait_get(VALUE self, VALUE spacename, VALUE key)
{
    VALUE deferred = hyperdex_ruby_client_get(self, spacename, key);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_get_partial(VALUE self, VALUE spacename, VALUE key, VALUE attributenames)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributenames__status_attributes(hyperdex_client_get_partial, self, spacename, key, attributenames);
}
VALUE
hyperdex_ruby_client_wait_get_partial(VALUE self, VALUE spacename, VALUE key, VALUE attributenames)
{
    VALUE deferred = hyperdex_ruby_client_get_partial(self, spacename, key, attributenames);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_put(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_put, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_put(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_put(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_put(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_put, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_put(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_put(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_put_if_not_exist(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_put_if_not_exist, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_put_if_not_exist(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_put_if_not_exist(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_del(VALUE self, VALUE spacename, VALUE key)
{
    return hyperdex_ruby_client_asynccall__spacename_key__status(hyperdex_client_del, self, spacename, key);
}
VALUE
hyperdex_ruby_client_wait_del(VALUE self, VALUE spacename, VALUE key)
{
    VALUE deferred = hyperdex_ruby_client_del(self, spacename, key);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_del(VALUE self, VALUE spacename, VALUE key, VALUE predicates)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates__status(hyperdex_client_cond_del, self, spacename, key, predicates);
}
VALUE
hyperdex_ruby_client_wait_cond_del(VALUE self, VALUE spacename, VALUE key, VALUE predicates)
{
    VALUE deferred = hyperdex_ruby_client_cond_del(self, spacename, key, predicates);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_add, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_atomic_add(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_add, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_atomic_add(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_sub, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_atomic_sub(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_sub, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_atomic_sub(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_mul, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_atomic_mul(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_mul, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_atomic_mul(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_div, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_atomic_div(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_div, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_atomic_div(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_mod, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_atomic_mod(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_mod, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_atomic_mod(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_and, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_atomic_and(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_and, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_atomic_and(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_or, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_atomic_or(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_or, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_atomic_or(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_atomic_xor, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_atomic_xor(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_atomic_xor, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_atomic_xor(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_string_prepend, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_string_prepend(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_string_prepend, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_string_prepend(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_string_append(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_string_append, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_string_append(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_string_append(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_string_append(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_string_append, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_string_append(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_string_append(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_list_lpush(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_list_lpush, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_list_lpush(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_list_lpush(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_list_lpush(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_list_lpush, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_list_lpush(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_list_lpush(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_list_rpush(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_list_rpush, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_list_rpush(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_list_rpush(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_list_rpush(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_list_rpush, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_list_rpush(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_list_rpush(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_set_add(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_set_add, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_set_add(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_set_add(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_set_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_set_add, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_set_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_set_add(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_set_remove(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_set_remove, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_set_remove(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_set_remove(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_set_remove(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_set_remove, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_set_remove(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_set_remove(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_set_intersect(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_set_intersect, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_set_intersect(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_set_intersect(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_set_intersect(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_set_intersect, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_set_intersect(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_set_intersect(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_set_union(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_set_union, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_set_union(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_set_union(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_set_union(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_set_union, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_set_union(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_set_union(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_add(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_add, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_add(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_add(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_add, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_add(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_remove(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_attributes__status(hyperdex_client_map_remove, self, spacename, key, attributes);
}
VALUE
hyperdex_ruby_client_wait_map_remove(VALUE self, VALUE spacename, VALUE key, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_map_remove(self, spacename, key, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_remove(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_attributes__status(hyperdex_client_cond_map_remove, self, spacename, key, predicates, attributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_remove(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE attributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_remove(self, spacename, key, predicates, attributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_add, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_atomic_add(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_add, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_add(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_atomic_add(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_sub, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_atomic_sub(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_sub, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_sub(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_atomic_sub(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_mul, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_atomic_mul(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_mul, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_mul(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_atomic_mul(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_div, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_atomic_div(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_div, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_div(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_atomic_div(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_mod, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_atomic_mod(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_mod, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_mod(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_atomic_mod(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_and, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_atomic_and(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_and, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_and(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_atomic_and(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_or, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_atomic_or(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_or, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_or(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_atomic_or(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_atomic_xor, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_atomic_xor(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_atomic_xor, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_atomic_xor(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_atomic_xor(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_string_prepend, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_string_prepend(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_string_prepend, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_string_prepend(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_string_prepend(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_map_string_append(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_mapattributes__status(hyperdex_client_map_string_append, self, spacename, key, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_map_string_append(VALUE self, VALUE spacename, VALUE key, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_map_string_append(self, spacename, key, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_cond_map_string_append(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    return hyperdex_ruby_client_asynccall__spacename_key_predicates_mapattributes__status(hyperdex_client_cond_map_string_append, self, spacename, key, predicates, mapattributes);
}
VALUE
hyperdex_ruby_client_wait_cond_map_string_append(VALUE self, VALUE spacename, VALUE key, VALUE predicates, VALUE mapattributes)
{
    VALUE deferred = hyperdex_ruby_client_cond_map_string_append(self, spacename, key, predicates, mapattributes);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_search(VALUE self, VALUE spacename, VALUE predicates)
{
    return hyperdex_ruby_client_iterator__spacename_predicates__status_attributes(hyperdex_client_search, self, spacename, predicates);
}

static VALUE
hyperdex_ruby_client_search_describe(VALUE self, VALUE spacename, VALUE predicates)
{
    return hyperdex_ruby_client_asynccall__spacename_predicates__status_description(hyperdex_client_search_describe, self, spacename, predicates);
}
VALUE
hyperdex_ruby_client_wait_search_describe(VALUE self, VALUE spacename, VALUE predicates)
{
    VALUE deferred = hyperdex_ruby_client_search_describe(self, spacename, predicates);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_sorted_search(VALUE self, VALUE spacename, VALUE predicates, VALUE sortby, VALUE limit, VALUE maxmin)
{
    return hyperdex_ruby_client_iterator__spacename_predicates_sortby_limit_maxmin__status_attributes(hyperdex_client_sorted_search, self, spacename, predicates, sortby, limit, maxmin);
}

static VALUE
hyperdex_ruby_client_group_del(VALUE self, VALUE spacename, VALUE predicates)
{
    return hyperdex_ruby_client_asynccall__spacename_predicates__status(hyperdex_client_group_del, self, spacename, predicates);
}
VALUE
hyperdex_ruby_client_wait_group_del(VALUE self, VALUE spacename, VALUE predicates)
{
    VALUE deferred = hyperdex_ruby_client_group_del(self, spacename, predicates);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}

static VALUE
hyperdex_ruby_client_count(VALUE self, VALUE spacename, VALUE predicates)
{
    return hyperdex_ruby_client_asynccall__spacename_predicates__status_count(hyperdex_client_count, self, spacename, predicates);
}
VALUE
hyperdex_ruby_client_wait_count(VALUE self, VALUE spacename, VALUE predicates)
{
    VALUE deferred = hyperdex_ruby_client_count(self, spacename, predicates);
    return rb_funcall(deferred, rb_intern("wait"), 0);
}
